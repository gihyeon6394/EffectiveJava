<h1>item 17. 변경 가능성을 최소화하라</h1>

> 인스턴스의 생성부터 파괴시점까지 내부의 수정이 불가능하도록 해라  
> 즉, 불변 클래스를 최우선으로 고려해라

- 필요한 경우가 아니면 모든 클래스는 불변이어야 한다
- 불변으로 만들 수 없는 클래스 <sup>값 클래스</sup>도 변경 부분을 최소화한다
    - 이유가 없다면 모든 필드는 private, final

<h2>불변 클래스</h2>

- **불변 클래스란?** 인스턴스 내부의 값을 **객체 파괴되는 순간까지 수정 불가능한 클래스**
- 설계, 구현, 사용이 쉽고
- 오류가 생길 여지가 적고
- 단순, 안전하다
- thread-safe 하여, 공유를 자유롭게 할 수 있다
- 불변 객체끼리 내부 데이터를 공유할 수 있다 <sub>ex. java.math.BigInteger<sub>
- 객체를 만들 때 불변 객체를 구성 요소로 하면 이점이 많다
- 불변 객체는 그 자체로 실패 원자성을 제공한다

<h3>단점</h3>

- 값이<sup>**조금이라도**</sup> 다르면 독립된 새로운 객체로 만들어야 한다
- 다단계 연산 <sup>multistep operation</sup> 별로 객체가 생성되어야 한다
    - 다단계 연산을 예측하여 내부를 영리하게 설계해 극복

<h2>불변 클래스 만드는 법</h2>

- 변경자<sup>객체의 상태를 변경하는 메서드</sup> 를 제공하지 않는다.
    - 외부에 비치는 값을 수정할 수 없다. 로 완화할 수 있다
- 클래스를 확장할 수 없도록 한다.
    - final 클래스로 선언하거나,
    - 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공
- 모든 필드를 final로 선언한다.
    - 설계자의 의도 명확
    - 다른 스레드로 넘겨도 문제없이 동작을 보장
- 모든 필드를 private로 선언한다.
    - 클라이언트가 필드에 직접 수정 못하게 막음
    - public 필드는 내부 표현 수정이 자유롭지 못함
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클라이언트가 가변 객체 필드 참조를 얻게 하지 말라
    - 생성자, 접근자, readObject 메서드에서 방어적 복사를 수행해야함 **<sub>함수형 프로그래밍</sub>**

<h3>주의사항</h3>

<h4>한번 만든 인스턴스는 최대한 재활용 하라</h4>

- public static final 상수로 제공
  ~~~~
  public final class Complex {
    public static final Complex ZERO = new Complex(0, 0);
    public static final Complex ONE = new Complex(1, 0);
    public static final Complex I = new Complex(0, 1);
  }
  ~~~~

<h4>복사 생성자는 필요 없다</h4>

- 정적 팩터리 메서드를 제공하여 한번 만든 인스턴스를 공유

<h4>final class 보다 private 생성자를 통해 구현하는 것이 더 유연</h4>

- 혹은 package-private 생성자
- 상속을 막을 수 있고, 다른 패키지에서는 접근 불가능
- 패키지 안에선 자유롭게 클래스를 만들 수 있다


